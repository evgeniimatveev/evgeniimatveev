name: Auto Update README v7.5

on:
  schedule:
    - cron: "15 12 * * *"   # Run daily at 12:15 UTC (‚âà 04:15 PST / 05:15 PDT)
  workflow_dispatch:
    inputs:
      banner_mode:
        description: "sequential | random | calendar"
        type: choice
        options: [sequential, random, calendar]
        default: sequential
      insight:
        description: "Override MLOPS_INSIGHT"
        type: string
        default: ""
      emojis:
        description: "Comma-separated emoji list (optional)"
        type: string
        default: ""
      jsonl_keep_lines:
        description: "Keep last N lines in update_log.jsonl"
        type: number
        default: 200
      txt_keep_lines:
        description: "Keep last N lines in update_log.txt"
        type: number
        default: 70
      table_n:
        description: "Show last N rows in README table"
        type: number
        default: 5
      commit_mode:
        description: "auto | dry-run | force"
        type: choice
        options: [auto, dry-run, force]
        default: auto
      next_update_hour:
        description: "UTC hour for Next Update badge"
        type: number
        default: 12
      next_update_min:
        description: "UTC minute for Next Update badge"
        type: number
        default: 15

permissions:
  contents: write   # Required to push README/log updates

concurrency:
  group: auto-update-readme
  cancel-in-progress: true

jobs:
  update-readme:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      # ---- Controls for the updater script ----
      BANNER_MODE: ${{ (github.event.inputs.banner_mode || 'sequential') }}
      BANNER_CALENDAR_MODE: ${{ (github.event.inputs.banner_mode || '') == 'calendar' }}
      MLOPS_INSIGHT: ${{ github.event.inputs.insight || '' }}
      SCHEDULE_BADGE: "24h_5m"  # display only

      # Emoji control
      BANNER_EMOJI_MODE: stable
      BANNER_EMOJIS: ${{ github.event.inputs.emojis || 'üéûÔ∏è,‚òï,ü™Ñ,ü§ñ,üåÖ,üåá,üìä,üåä,üåà,‚ö°' }}

      # Logs / tables
      JSONL_KEEP_LINES: ${{ github.event.inputs.jsonl_keep_lines || 200 }}
      TXT_KEEP_LINES:   ${{ github.event.inputs.txt_keep_lines   || 70  }}
      LOG_TABLE_N:      ${{ github.event.inputs.table_n          || 5   }}

      # Commit behavior
      COMMIT_MODE:      ${{ github.event.inputs.commit_mode      || 'auto' }}

      # Next Update badge target (UTC) ‚Äî keep in sync with cron above
      NEXT_UPDATE_HOUR: ${{ github.event.inputs.next_update_hour || 12 }}
      NEXT_UPDATE_MIN:  ${{ github.event.inputs.next_update_min  || 15 }}

      # ---- JITTER (up to 10 minutes) ----
      JITTER_MAX_SEC: 600

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Ensure dirs (idempotent)
        shell: bash
        run: |
          mkdir -p .ci badges logs
          [ -f badges/next_update.json ] || echo '{"schemaVersion":1,"label":"Next","message":"‚Äî","color":"lightgrey"}' > badges/next_update.json

      # Apply jitter only for scheduled runs (manual runs start immediately)
      - name: Random jitter (sleep up to 10 min)
        if: ${{ github.event_name == 'schedule' }}
        shell: bash
        run: |
          S=$(( RANDOM % ${JITTER_MAX_SEC:-0} + 1 ))
          echo "Sleeping for $S sec to spread load..."
          sleep "$S"

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.10"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Configure Git author
        shell: bash
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: Install Python deps
        if: hashFiles('requirements.txt') != ''
        shell: bash
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run updater (with logs)
        shell: bash
        run: |
          set -euo pipefail
          python update_readme.py 2>&1 | tee logs/updater.out

      # ---------- NEW: Stable followers/stars via endpoint JSON ----------
      - name: Update GitHub metrics badges (followers & stars)
        env:
          GH_USER: evgeniimatveev
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}   # default Actions token (public read is enough)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p badges

          # Followers
          followers=$(curl -fsSL -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/users/${GH_USER}" \
            | python - <<'PY'
import sys, json
d=json.load(sys.stdin)
print(d.get("followers",0))
PY
          )

          # Stars across owned non-fork repos (first 100; GitHub caps per_page=100)
          stars=$(curl -fsSL -H "Authorization: Bearer $GH_TOKEN" \
            "https://api.github.com/search/repositories?q=user:${GH_USER}+fork:false&per_page=100" \
            | python - <<'PY'
import sys, json
d=json.load(sys.stdin)
print(sum(i.get("stargazers_count",0) for i in d.get("items",[])))
PY
          )

          # Write shields endpoint JSONs
          cat > badges/github_followers.json <<EOF
{"schemaVersion":1,"label":"followers","message":"$followers","color":"blue","logo":"github"}
EOF
          cat > badges/github_stars.json <<EOF
{"schemaVersion":1,"label":"stars","message":"$stars","color":"yellow","logo":"github"}
EOF

      # ---------- Optional: patch README links to endpoint (idempotent) ----------
      - name: Patch README followers/stars badges to endpoint
        shell: bash
        run: |
          set -euo pipefail
          FOLLOWERS_EP="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${GITHUB_REF_NAME}/badges/github_followers.json&style=for-the-badge&cacheSeconds=3600"
          STARS_EP="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${GITHUB_REF_NAME}/badges/github_stars.json&style=for-the-badge&cacheSeconds=3600"

          awk -v f="$FOLLOWERS_EP" -v s="$STARS_EP" '
            { gsub(/https:\/\/img\.shields\.io\/github\/followers\/[^ )"]+/, f) }
            { gsub(/https:\/\/img\.shields\.io\/github\/stars\/[^ )"]+/, s) }
            { print }
          ' README.md > README.tmp && mv README.tmp README.md

      # ---------- Badges / logs rendering ----------
      - name: Read totals & fallback text
        shell: bash
        run: |
          python - <<'PY'
          import os, json, datetime, pathlib
          env_path = os.environ['GITHUB_ENV']

          tot = ''
          try:
              tot = pathlib.Path('.ci/update_count.txt').read_text(encoding='utf-8').strip()
          except Exception:
              pass

          msg = ''
          try:
              d = json.loads(pathlib.Path('badges/next_update.json').read_text(encoding='utf-8'))
              msg = d.get('message','')
          except Exception:
              pass

          def compute():
              try:
                  h=int(os.getenv('NEXT_UPDATE_HOUR','12')); m=int(os.getenv('NEXT_UPDATE_MIN','15'))
              except Exception:
                  h=12; m=15
              now=datetime.datetime.utcnow()
              eta=now.replace(hour=h, minute=m, second=0, microsecond=0)
              if now>=eta: eta+=datetime.timedelta(days=1)
              left=eta-now
              T=int(left.total_seconds())
              H=T//3600; M=(T%3600)//60
              return f"in {M}m" if H==0 else f"in {H}h {M:02d}m"

          if not msg:
              msg = compute()

          with open(env_path,'a') as env:
              if tot: env.write(f"TOTAL_UPDATES={tot}\n")
              env.write(f"NEXT_UPDATE_TEXT={msg}\n")
          PY

      - name: Append & trim update_log.txt
        shell: bash
        run: |
          {
            echo "--------------------------------------"
            echo "Updated on: $(date -u) (UTC)"
            echo "Triggered by: ${{ github.event_name }}"
            echo "Commit SHA: ${{ github.sha }}"
            echo "Run ID: ${{ github.run_id }}"
            echo "Run number: ${{ github.run_number }}"
            echo "--------------------------------------"
          } >> update_log.txt
          tail -n ${TXT_KEEP_LINES} update_log.txt > temp_log.txt || true
          mv temp_log.txt update_log.txt || true

      - name: Trim JSON log (keep last N lines)
        shell: bash
        run: |
          [ -f update_log.jsonl ] || : > update_log.jsonl
          tail -n ${JSONL_KEEP_LINES} update_log.jsonl > update_log.jsonl.tmp || true
          mv update_log.jsonl.tmp update_log.jsonl || true

      - name: Render last N updates into README (accordion)
        shell: bash
        run: |
          python - <<'PY'
          import json, pathlib, re, os
          N = int(os.getenv("LOG_TABLE_N", "5"))
          log = pathlib.Path("update_log.jsonl")
          readme_p = pathlib.Path("README.md")

          def esc_md(s: str) -> str:
              return str(s).replace("|", "&#124;").replace("\n", " ").strip()

          rows = []
          if log.exists():
              lines = [l for l in log.read_text(encoding="utf-8").splitlines() if l.strip()][-N:]
              for line in reversed(lines):
                  d = json.loads(line)
                  banner_str = "{}/{} ({})".format(
                      d.get("banner_index","?"), d.get("banner_total","?"), d.get("banner_file","")
                  )
                  insight = esc_md(d.get("insight_preview",""))
                  if len(insight) > 140:
                      insight = insight[:137] + "‚Ä¶"
                  row = (
                      "| {} | {} | `{}` | {} | {}/{} | {} |".format(
                          esc_md(d.get("ts_utc","")),
                          esc_md(d.get("run_number","")),
                          esc_md(d.get("sha","")),
                          esc_md(banner_str),
                          esc_md(d.get("event","")),
                          esc_md(d.get("actor","")),
                          insight
                      )
                  )
                  rows.append(row)

          headers = ["Time (UTC)", "Run", "SHA", "Banner", "Event/Actor", "Insight"]
          sep = "|" + "|".join(["---"] * len(headers)) + "|"

          table = [
              "<details><summary>üóÇÔ∏è<b>Recent updates (last {})</b></summary>".format(N),
              "",
              "| " + " | ".join(headers) + " |",
              sep,
              *(rows or ["| ‚Äî | ‚Äî | ‚Äî | ‚Äî | ‚Äî | ‚Äî |"]),
              "",
              "</details>",
          ]
          new_block = "\n".join(["<!-- LOG:START -->", *table, "<!-- LOG:END -->"])

          readme = readme_p.read_text(encoding="utf-8")
          pattern = r"<!-- LOG:START -->.*?<!-- LOG:END -->"
          if re.search(pattern, readme, flags=re.S):
              readme = re.sub(pattern, new_block, readme, flags=re.S)
          else:
              readme = readme.rstrip() + "\n\n" + new_block + "\n"
          readme_p.write_text(readme, encoding="utf-8")
          PY

      - name: Show last 10 JSONL lines
        shell: bash
        run: |
          set -euo pipefail
          echo "Last 10 JSONL lines:"
          if [ -f update_log.jsonl ]; then
            tail -n 10 update_log.jsonl
          else
            echo "update_log.jsonl not found yet"
          fi

      - name: Update STATUS line in README
        shell: bash
        run: |
          short_sha="${GITHUB_SHA:0:7}"
          NOW_UTC="$(date -u +"%Y-%m-%d %H:%M UTC")"
          NOW_BADGE=$(printf "%s" "$NOW_UTC" | sed 's/ /%20/g; s/:/%3A/g')
          MODE_BADGE="${COMMIT_MODE}"
          NEXT_ENDPOINT="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${GITHUB_REF_NAME}/badges/next_update.json"

          SMOKE_LINK="https://github.com/${GITHUB_REPOSITORY}/actions/workflows/smoke.yml"
          SMOKE_BADGE="${SMOKE_LINK}/badge.svg?branch=${GITHUB_REF_NAME}&t=${GITHUB_RUN_NUMBER}"

          STATUS="<p align=\"center\">
          <img src=\"https://img.shields.io/static/v1?label=Updated&message=${NOW_BADGE}&color=0e8a16&labelColor=30363d&logo=clock&cacheSeconds=60&t=${GITHUB_RUN_NUMBER}\" />
          <img src=\"https://img.shields.io/badge/Schedule-${SCHEDULE_BADGE}-2ea44f?cacheSeconds=300\" />
          <img src=\"https://img.shields.io/endpoint?url=${NEXT_ENDPOINT}&cacheSeconds=120&t=${GITHUB_RUN_NUMBER}\" />
          <img src=\"https://img.shields.io/static/v1?label=Next%20Update&message=${NEXT_UPDATE_TEXT// /%20}&color=757575&labelColor=30363d&cacheSeconds=600\" />
          <img src=\"https://img.shields.io/badge/Rotation-%23${GITHUB_RUN_NUMBER}-1f6feb?cacheSeconds=60\" />
          <img src=\"https://img.shields.io/badge/Commit-${short_sha}-9cf?cacheSeconds=300\" />
          <img src=\"https://img.shields.io/static/v1?label=Updates&message=${TOTAL_UPDATES:-?}&color=0ea5e9&cacheSeconds=300\" />
          <img src=\"https://img.shields.io/badge/Event-${GITHUB_EVENT_NAME}-8a2be2?cacheSeconds=300\" />
          <img src=\"https://img.shields.io/badge/Mode-${MODE_BADGE}-grey?cacheSeconds=60\" />
          <a href=\"${SMOKE_LINK}\"><img src=\"${SMOKE_BADGE}\" alt=\"Daily Smoke (pytest - m smoke)\" /></a>
          </p>"

          awk -v r="$STATUS" '
            /<!-- STATUS:START -->/ {print; print r; f=1; next}
            /<!-- STATUS:END -->/   {f=0}
            !f
          ' README.md > README.tmp && mv README.tmp README.md

      - name: Update STATUS2 line in README
        shell: bash
        run: |
          NEXT_ENDPOINT="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${GITHUB_REF_NAME}/badges/next_update.json"
          SMOKE_LINK="https://github.com/${GITHUB_REPOSITORY}/actions/workflows/smoke.yml"
          SMOKE_BADGE="${SMOKE_LINK}/badge.svg?branch=${GITHUB_REF_NAME}&t=${GITHUB_RUN_NUMBER}"

          LOW_STATUS="<p align=\"left\">
          <img src=\"https://img.shields.io/endpoint?url=${NEXT_ENDPOINT}&cacheSeconds=120&t=${GITHUB_RUN_NUMBER}\" />
          <img src=\"https://img.shields.io/static/v1?label=Next%20Update&message=${NEXT_UPDATE_TEXT// /%20}&color=757575&labelColor=30363d&cacheSeconds=600\" />
          <img src=\"https://img.shields.io/static/v1?label=Updates&message=${TOTAL_UPDATES:-?}&color=0ea5e9&labelColor=30363d&cacheSeconds=300\" />
          <a href=\"${SMOKE_LINK}\"><img src=\"${SMOKE_BADGE}\" alt=\"Daily Smoke (pytest - m smoke)\" /></a>
          </p>"

          awk -v r="$LOW_STATUS" '
            /<!-- STATUS2:START -->/ {print; print r; f=1; next}
            /<!-- STATUS2:END -->/   {f=0}
            !f
          ' README.md > README.tmp && mv README.tmp README.md

      - name: Heartbeat (force a diff on schedule/force)
        if: ${{ github.event_name == 'schedule' || env.COMMIT_MODE == 'force' }}
        shell: bash
        run: |
          mkdir -p .ci
          echo "$(date -u +'%Y-%m-%d %H:%M:%S') UTC  run=${GITHUB_RUN_NUMBER} sha=${GITHUB_SHA:0:7}" >> .ci/heartbeat.log

      - name: Commit changes (if any)
        id: commit
        if: env.COMMIT_MODE != 'dry-run'
        shell: bash
        run: |
          set -e
          git add README.md update_log.txt update_log.jsonl .ci/heartbeat.log .ci/update_count.txt \
                  badges/next_update.json badges/github_followers.json badges/github_stars.json 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
            echo "No changes to commit."
          else
            msg="Auto-update README (banner/status/insight rotation + logs) [v7.5]"
            [ "${COMMIT_MODE}" = "force" ] && msg="${msg} [force]"
            git commit -m "$msg"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Push changes
        if: env.COMMIT_MODE != 'dry-run' && steps.commit.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          for i in 1 2 3; do
            if git push; then
              echo "Pushed successfully"
              exit 0
            fi
            echo "Push failed (attempt $i). Retrying in $((i*3))s..."
            sleep $((i*3))
            git pull --rebase || true
          done
          echo "Push failed after 3 attempts"
          exit 1

      - name: Show updater tail
        if: always()
        shell: bash
        run: |
          if [ -f logs/updater.out ]; then
            echo "=== updater.out (last 120 lines) ==="
            tail -n 120 logs/updater.out
          else
            echo "logs/updater.out not found"
          fi

      - name: Write job summary
        shell: bash
        run: |
          {
            echo "## README Auto-Update v7.5"
            echo "- **Run**: #${{ github.run_number }}"
            echo "- **Event**: ${{ github.event_name }}"
            echo "- **Commit**: ${{ github.sha }}"
            echo "- **Schedule**: ${SCHEDULE_BADGE}"
            echo "- **Mode**: ${COMMIT_MODE}"
            echo "- **Total Updates**: ${TOTAL_UPDATES:-?}"
            echo "- **Next Update (text)**: ${NEXT_UPDATE_TEXT}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload logs as artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: update_logs
          path: |
            logs/updater.out
            update_log.txt
            update_log.jsonl
            .ci/heartbeat.log
            .ci/update_count.txt
          retention-days: 7
